-----Cut Here-----Cut Here-----Cut Here-----Cut Here-----
#!/bin/sh
# shar:	Shell Archiver
#	Run the following text with /bin/sh to create:
#	src/Makefile
#	src/README
#	src/asql.l
#	src/asql.y
#	src/asqlca.h
#	src/asqlda.h
#	src/test.c
#	src/module.c
#	src/esqlc.c
#	src/sqlfunc.c
#	src/yf.c
#	test/embed01.esql
#	test/embed02.esql
#	test/tm01.mod
sed 's/^X//' << 'SHAR_EOF' > src/Makefile
X#
X# This software is Copyright (c)  1989 by Leroy Cain.
X#
X# Permission is hereby granted to copy, reproduce, redistribute or
X# otherwise use this software as long as: there is no monetary
X# profit gained specifically from the use or reproduction of this
X# software, it is not sold, rented, traded or otherwise marketed
X# except under licence from the author, and this copyright notice
X# is included prominently in any copy made.
X#
X# The author makes no claims as to the fitness or correctness of
X# this software for any use whatsoever, and it is provided as is. 
X# Any use of this software is at the user's own risk.
X#
X#
X#ESQL Languages
X# C
X# COBOL
X# FORTRAN
X# PASCAL
X# PLI
XLANG=C
X
X# if you have ansi c
X#AFLAG= -Dansi
X
Xall: ansi_sql esql module
X
X##############################################################################
X# ansi_sql is an interactive version of SQL
X
Xansi_sql: test.o libsql.a
X	cc -o ansi_sql test.o libsql.a
X
Xtest.o: test.c
X	cc -c $(AFLAG) test.c
X
X##############################################################################
X# This section produces a library of function that is called by ESQL
X# and MODULE programs.
X
Xlibsql.a: y.inter.o sqlfunc.o
X	ar r libsql.a y.inter.o sqlfunc.o
X#	ranlib libsql.a
X
Xy.inter.o: y.inter.c ilex.yy.c
X	cc -c -DINTERNAL $(AFLAG) y.inter.c
X
Xy.inter.c: asql.y yf
X	yf INTERNAL <asql.y >inter.y
X	yacc -v inter.y
X	mv y.tab.c y.inter.c
X
X##############################################################################
X
Xesql: y.esql.o esqlc.o
X	cc -o esql esqlc.o y.esql.o
X
Xesqlc.o:esqlc.c
X	cc -c $(AFLAG) esqlc.c
X
Xy.esql.o: y.esql.c lex.yy.c
X	cc -c -DEMBEDDED y.esql.c
X
Xy.esql.c: asql.y yf
X	yf EMBEDDED <asql.y >esql.y
X	yacc -vd esql.y
X	mv y.tab.c y.esql.c
X	mv y.tab.h y.esql.h
X
X##############################################################################
X
Xmodule: module.o y.mod.o
X	cc -o module module.o y.mod.o
X
Xmodule.o:module.c
X	cc -c $(AFLAG) module.c
X
Xy.mod.o: y.mod.c lex.yy.c
X	cc -c -DMODULE y.mod.c
X
Xy.mod.c: asql.y yf
X	yf MODULE <asql.y >mod.y
X	yacc -v mod.y
X	mv y.tab.c y.mod.c
X
X##############################################################################
X
Xlex.yy.c: asql.l
X	lex asql.l
X
Xilex.yy.c: asql.l
X	lex asql.l
X	sed -e "s/getc(yyin)/(*sqlbuf++)/1" lex.yy.c >ilex.yy.c
X
X##############################################################################
X# yf is a filter program to separate up asql.y into to three componets
X
Xyf:yf.c
X	cc -o yf yf.c
X
X##############################################################################
X# clean things up
Xclean:
X	rm *.o esql.y inter.y mod.y ilex.yy.c lex.yy.c libsql.a \
X	y.esql.c y.mod.c y.inter.c
SHAR_EOF
sed 's/^X//' << 'SHAR_EOF' > src/README
XThis file contains a number of letters and postings that describe and
Xclarify the use and functionality of this parser.  If you have any
Xquestion contact me as follows:
X
XLeroy Cain;      Columbia Union College;      Mathematical Sciences Department
X7600 Flower Ave. WH406;  	              Takoma Park, Md 20912
X(301) 891-4172				      uunet!cucstud!lcain
X-----------------------------------------------------------------------------
X-----------------------------------------------------------------------------
X
XThis is an parser for ISO/ANSI SQL written useing LEX, YACC, and C.
XIt provides syntax check and a frame for building a completed query processor.
XSee	ANSI X3.135-1986 and ANSI X3.135.1-198x Addendum 1
X	ISO 9075-1987(E) Addendum 1
X
XUnlike the previous SQL parser I posted this one can be process with
Xa normal YACC so everyone should be able to use it.
X
XThere are three parts:
X	1. Module	-- This processes the module specification and
X			produces function calls to which ever language
X			is specificied.
X	2. Embedded	-- This processes the embedded SQL specification and
X			produces function calls to which ever language
X			is specificied.
X	3. Internal	-- This processes SQL command passed to the function
X			interface.
X
XNotes:
X	In Module and Embedded you add the code to produce the function
X	calls.
X	Language specificied for use with Module and Embedded C, COBOL,
X	FORTRAN, Pascal, PL/1.
X	C as a possible langauge for Module and Embedded is not specificied
X	in the ANSI specs.  This is the only place I deveated. 
X
XHow to use this package
X	Running make will produce the executables module, esql, ansi_sql.
X
X-----------------------------------------------------------------------------
X-----------------------------------------------------------------------------
X
X> 
X> 
X> 
X> Leroy,
X> 
X> I obtained your sql parser off of the net.  I was able to compile it
X> without any problems (except for Xenix needing a library to be ranlib'ed
X> before use).  The programs seem to run, but I don't know what is
X> supposed to come out.  I would like to be able to integrate it into a
X> program I use (and developed), but am stumped as to what is going on,
X> and how to do the integration.
X> 
X> Could you send me some pointers as to 1) how to test it here, and 2) how
X> to integrate it into my program?
X> 
X> 
X> Thanks.
X> 
X> 
X> 
X> JB
X> -- 
X> Jonathan Bayer		Intelligent Software Products, Inc.
X> (201) 245-5922		500 Oakwood Ave.
X> jbayer@ispi.COM		Roselle Park, NJ   07204    
X> 
X
XJonathan,
X
X	The parser is billed as a frame work from which to build
XSQL query processing componet.  The basic idea is to drop C code into
Xthe LEX and YACC files and extend the existing C files.  To specificly
Xanswer question:
X
X1. Testing.
X	There are three executables ansi_sql, esql and module.  Each
X	one corrisponds to the three componets of the system.  The function
X	level function call interface which is useful for talk with a
X	database engine is test by ansi_sql;  The Embedded SQL is test by
X	esql; and the Module interface is test by module.
X
X	When you run ansi_sql you should get a "1>>"  this is prompting
X	for a SQL command.  Try "SELECT * FROM Junk;" it should respond with
X	Reserved Words 'SELECT'
X	Reserved Words 'FROM'
X	Got an IDENTIFIER 'Junk'
X	1>>
X	exit using control d.
X
X	Esql can be passed a file "esql file.esql"
X
X	file.esql:
X
X	main()
X	{
X	EXEC SQL BEGIN DECLARE SECTION END EXEC
X	CHAR	Tvar1[10];
X	INT	Tvar2;
X	CHAR	Tvar3[10];
X	FLOAT	Tvar4;
X	EXEC SQL END DECLARE SECTION END EXEC
X	}
X
X
X	Module can be pass a file  "module file.mod"
X
X	file.mod:
X
X	MODULE Test_001
X	LANGUAGE C
X	AUTHORIZATION Lcain
X	PROCEDURE Close_cur SQLCODE;
X		CLOSE Cur1;
X
X	PROCEDURE Commit_tran SQLCODE;
X		COMMIT WORK;
X
X	PROCEDURE Delete_p SQLCODE;
X	DELETE FROM Tabname
X	WHERE CURRENT OF Curname;
X
X	PROCEDURE Delete_s SQLCODE;
X		DELETE FROM Tabname
X		WHERE Col1 = +5.0;
X
X	PROCEDURE Fetch_ SQLCODE;
X		FETCH Curname INTO Col1 INDICATOR Colind1;
X
X	PROCEDURE Insert_ SQLCODE;
X		INSERT INTO Tabname (Col1,Col2,Col3)
X		VALUES ( 'Test',+5,-5.8 );
X
X	PROCEDURE Open_cur SQLCODE;
X		OPEN Cur1;
X
X	PROCEDURE Rollback_ SQLCODE;
X		ROLLBACK WORK;
X
X	PROCEDURE List_table Colname CHARACTER( 10) SQLCODE;
X		SELECT Colname
X		INTO Colname INDICATOR Colind
X		FROM Tabname;
X
X	PROCEDURE Update_p SQLCODE;
X		UPDATE Tabname
X		SET Col1 = Col1 * +3.5
X		WHERE CURRENT OF Curname;
X
X	PROCEDURE Update_s SQLCODE;
X		UPDATE Tabname
X		SET Col2 = Col2 * +3.5
X		WHERE Col1 = 'Test';
X
X
X2. Integerating into your product.
X	Since I don't know how your product is structure I will give you a
X	general answer.  If you need more specific information I will need to
X	know more about you product.
X	See the following documents for information on the Standard:
X
X		ANSI X3.135-1986 and ANSI x3.135.1-198x
X		ISO 9075-1987(E) Addendum-1
X	
X	By adding the appropriate C code to the asql.y file one can create
X	parsers that are usable with the function interface, ESQL and
X	Module componets. At least this is the theory.  Only common code
X	should go in there.  Any code specific to each componet ( other
X	than when inclose in the @<componet designator> @ condition
X	YACCalation) should be put in a separate file.
X
X	The function level interface can be tied to a database engine.
X	Note that the function level interface is incomplete and pretty
X	shitty.  So for now you have to invent your own, Sorry about that.
X
X	The ESQL takes a file in; filters the ESQL statements; and
X	substitutes function call of your choice.  You may want to
X	tie it to the database to get info on fields and tables for
X	sematic processing.
X
X	The Module interface works about the same as ESQL except
X	there is no high level language in module files.  
X
XNOTE:
X	I found a bug  int test.c
X	Add at Line 50 of test
X	if(c==EOF)
X		return c;
X
X	Thanks for you input.
X
XLeroy Cain;      Columbia Union College;      Mathematical Sciences Department
X7600 Flower Ave. WH406;  	              Takoma Park, Md 20912
X(301) 891-4172				      uunet!cucstud!lcain
X-----------------------------------------------------------------------------
X-----------------------------------------------------------------------------
X
X> 
X> Leroy,
X> 
X> I took your parser off the net, for which, thanks very much.
X> 
X> I also saw your note to Jonathan Bayer on how to use it.
X> 
X> Unfortunately, I am still a little confused. I would have expected
X> ansi_sql to interactively take in SQL queries and to give me
X> parse trees that I could transform into something suitable
X> for use with my query evaluator.
X> 
X
XDerek,
X
XThe original goal was to create a basic ANSI standard SQL parser,
Xtherefore I didn't put in the code to actually generate parses trees.
XI do plain to do this in the future but I haven't schedule a time to
Xwork on it yet.
X
X> Can you supply further info on what I must do to what in order to
X> get hold of such parse trees, please.
X> 
X
XI will attempt to give a quit overview of what to do.  First you need
Xsome structures.  In the first pass at building parse trees try something
Xline this:
X
Xtypedef struct node
X{
X	int	node_type;	/* the type of node */
X	union
X	{
X		long	int4;
X		char	*str;
X	}value;			/* Value of node if any */
X	struct node	lnode;	/* Left branch of tree */
X	struct node	rnode;	/* Right branch of tree */
X}NODE;
X
XExamples of node types
X
X/* constains */
X#define PT_INT4		0070	/* Integer constaint 32bit */
X#define PT_STRING	0040	/* String constain */
X
X/* operators */
X#define PT_ADD		0210	/* Addition operator */
X#define PT_SUB		0211	/* Subtraction operator */
X
X/* other */
X#define PT_SELECT	0301	/* Select statement */
X#define PT_CREATE	0311	/* Create statement */
X
XAfter you get the hang of it you will see where you can compress the
Xtree by putting more information in the value part of the structure.
X
Xtry generating trees and then print them out and see if you get the same
Xthing.  hope this helps.
X
X> Thank you very much,
X> 
X> Derek.
X> 
X
X
SHAR_EOF
sed 's/^X//' << 'SHAR_EOF' > src/asql.l
X%{
X /*
X * This software is Copyright (c)  1989 by Leroy Cain.
X *
X * Permission is hereby granted to copy, reproduce, redistribute or
X * otherwise use this software as long as: there is no monetary
X * profit gained specifically from the use or reproduction or this
X * software, it is not sold, rented, traded or otherwise marketed
X * except under licence from the author, and this copyright notice
X * is included prominently in any copy made.
X *
X * The author makes no claims as to the fitness or correctness of
X * this software for any use whatsoever, and it is provided as is. 
X * Any use of this software is at the user's own risk.
X *
X */
X%}
X/*				5.1 <character> 			*/
XDIGIT		[0-9]
XLOWER		[a-z]
XUPPER		[A-Z]
XLETTER		({UPPER}|{LOWER})
XSPECIAL		[!-/]
XEOL		[\n\r]
XCHARACTER	{DIGIT}|{LETTER}|{SPECIAL}
X
X/* 				5.2 <literal> 				*/
XUINT		{DIGIT}+
XSINT		[+-]{DIGIT}+
XENL		([+-])?({UINT}"."{UINT})|({UINT}".")|("."{UINT})
XANL		{ENL}[Ee]{SINT}
X
X%%
X{UPPER}("_"|{LETTER}|{DIGIT})*	
X{
Xint	rw;
X/* 				5.3 <token>				*/
X	if(rw=rwlookup(yytext))
X	{
X		printf("Reserved Words '%s'\n",yytext);
X		return rw;
X	}
X	else
X	{
X		printf("Got an IDENTIFIER '%s'\n",yytext);
X		return IDENTIFIER;
X	}
X}
X
X({ENL})|({ANL})		
X{
X	return NUMERIC;
X}
X
X{SINT}	
X{
X	return SINTEGER;
X}
X
X{UINT}	
X{
X	return UINTEGER;
X}
X
X\'[^\']*\'	
X{
X	return STRING;
X}
X","	return COMA;
X"("	return LPAREN;
X")"	return RPAREN;
X"["	return LBRACKET;
X"]"	return RBRACKET;
X"<"	return GT;
X">"	return LT;
X"."	return PERIOD;
X":"	return COLON;
X";"	return SEMICOLON;
X"="	return EQ;
X"*"	return MULT;
X"+"	return PLUS;
X"-"	return SUB;
X"/"	return DIV;
X"<>"	return NEQ;
X">="	return GE;
X"<="	return LE;
X--[^\n]*\n	/* COMMENT */;
X[ \n\t]		/* SPACE */;
X.	return ERROR;
X%%
X
Xstatic struct
X{
X	char	*word;
X	int	token;
X} rwords[] =
X{
X"ALL", RW_ALL,
X"AND", RW_AND,
X"ANY", RW_ANY,
X"AS", RW_AS,
X"ASC", RW_ASC,
X"AUTHORIZATION", RW_AUTHORIZATION,
X"AVG", RW_AVG,
X"BEGIN", RW_BEGIN,
X"BETWEEN", RW_BETWEEN,
X"BY", RW_BY,
X"CHAR", RW_CHAR,
X"CHARACTER", RW_CHARACTER,
X"CHECK", RW_CHECK,
X"CLOSE", RW_CLOSE,
X"COMMIT", RW_COMMIT,
X"CONTINUE", RW_CONTINUE,
X"COUNT", RW_COUNT,
X"CREATE", RW_CREATE,
X"CURRENT", RW_CURRENT,
X"CURSOR", RW_CURSOR,
X"DEC", RW_DECIMAL,
X"DECIMAL", RW_DECIMAL,
X"DECLARE", RW_DECLARE,
X"DEFAULT", RW_DEFAULT,
X"DELETE", RW_DELETE,
X"DESC", RW_DESC,
X"DISTINCT", RW_DISTINCT,
X"DOUBLE", RW_DOUBLE,
X"END", RW_END,
X"ESCAPE", RW_ESCAPE,
X"EXEC", RW_EXEC,
X"EXISTS", RW_EXISTS,
X"FETCH", RW_FETCH,
X"FLOAT", RW_FLOAT,
X"FOR", RW_FOR,
X"FOREIGN", RW_FOREIGN,
X"FOUND", RW_FOUND,
X"FROM", RW_FROM,
X"GO", RW_GO,
X"GOTO", RW_GOTO,
X"GRANT", RW_GRANT,
X"GROUP", RW_GROUP,
X"HAVING", RW_HAVING,
X"IN", RW_IN,
X"INDICATOR", RW_INDICATOR,
X"INSERT", RW_INSERT,
X"INT", RW_INT,
X"INTEGER", RW_INTEGER,
X"INTO", RW_INTO,
X"IS", RW_IS,
X"KEY", RW_KEY,
X"LANGUAGE", RW_LANGUAGE,
X"LIKE", RW_LIKE,
X"MAX", RW_MAX,
X"MIN", RW_MIN,
X"MODULE", RW_MODULE,
X"NOT", RW_NOT,
X"NULL", RW_NULL,
X"NUMERIC", RW_NUMERIC,
X"OF", RW_OF,
X"ON", RW_ON,
X"OPEN", RW_OPEN,
X"OPTION", RW_OPTION,
X"OR", RW_OR,
X"ORDER", RW_ORDER,
X"PRECISION", RW_PRECISION,
X"PRIMARY", RW_PRIMARY,
X"PRIVILEGES", RW_PRIVILEGES,
X"PROCEDURE", RW_PROCEDURE,
X"PUBLIC", RW_PUBLIC,
X"REAL", RW_REAL,
X"REFERENCES", RW_REFERENCES,
X"ROLLBACK", RW_ROLLBACK,
X"SCHEMA", RW_SCHEMA,
X"SECTION", RW_SECTION,
X"SELECT", RW_SELECT,
X"SET", RW_SET,
X"SMALLINT", RW_SMALLINT,
X"SOME", RW_SOME,
X"SQL", RW_SQL,
X"SQLCODE", RW_SQLCODE,
X"SQLERROR", RW_SQLERROR,
X"SUM", RW_SUM,
X"TABLE", RW_TABLE,
X"TO", RW_TO,
X"UNION", RW_UNION,
X"UNIQUE", RW_UNIQUE,
X"UPDATE", RW_UPDATE,
X"USER", RW_USER,
X"VALUES", RW_VALUES,
X"VIEW", RW_VIEW,
X"WHENEVER", RW_WHENEVER,
X"WHERE", RW_WHERE,
X"WITH", RW_WITH,
X"WORK", RW_WORK,
X
X/* Embedded Langauge specific reserved words */
X"C", RW_C,
X
X#ifdef EB_COBOL
X	"COBOL", RW_COBOL,
X#endif
X
X#ifdef EB_FORTRAN
X	"FORTRAN", RW_FORTRAN,
X#endif
X
X#ifdef EB_PASCAL
X	"PASCAL", RW_PASCAL,
X#endif
X
X#ifdef EB_PLI
X	"PLI", RW_PLI,
X#endif
X"",0
X};
X
X/*---------------------------------------------------------------------------*/
X/* rwlookup	-- Looks of reservered words and return token number.	     */
X/*---------------------------------------------------------------------------*/
Xrwlookup(rw)
Xchar	*rw;	/* Pointer to reservered word. */
X{
Xint	x;	/* Subscript to reserved word list */
X
X	for(x=0;rwords[x].token && strcmp(rw,rwords[x].word);x++);
X	return rwords[x].token;
X}
SHAR_EOF
sed 's/^X//' << 'SHAR_EOF' > src/asql.y
X/*
X * This software is Copyright (c)  1989 by Leroy Cain.
X *
X * Permission is hereby granted to copy, reproduce, redistribute or
X * otherwise use this software as long as: there is no monetary
X * profit gained specifically from the use or reproduction of this
X * software, it is not sold, rented, traded or otherwise marketed
X * except under licence from the author, and this copyright notice
X * is included prominently in any copy made.
X *
X * The author makes no claims as to the fitness or correctness of
X * this software for any use whatsoever, and it is provided as is. 
X * Any use of this software is at the user's own risk.
X *
X */
X%token		IDENTIFIER
X%token		UINTEGER
X%token		SINTEGER
X%token		NUMERIC
X%token		STRING
X
X%token		COMA
X%token		LPAREN
X%token		RPAREN
X%token		LBRACKET
X%token		RBRACKET
X%token		PERIOD
X%token		COLON
X%token		SEMICOLON
X%right		NEG 
X%left		DIV MULT
X%left		PLUS SUB
X%left		EQ NEQ GT LT GE LE
X%token		ERROR
X
X
X%token		RW_ALL
X		RW_AND
X		RW_ANY
X		RW_AS
X		RW_ASC
X		RW_AUTHORIZATION
X		RW_AVG
X		RW_BEGIN
X		RW_BETWEEN
X		RW_BY
X		RW_CHARACTER
X		RW_CHECK
X		RW_CLOSE
X		RW_COMMIT
X		RW_CONTINUE
X		RW_COUNT
X		RW_CREATE
X		RW_CURRENT
X		RW_CURSOR
X		RW_DECIMAL
X		RW_DECLARE
X		RW_DEFAULT
X		RW_DELETE
X		RW_DESC
X		RW_DISTINCT
X		RW_DOUBLE
X		RW_END
X		RW_ESCAPE
X		RW_EXEC
X		RW_EXISTS
X		RW_FETCH
X		RW_FLOAT
X		RW_FOR
X		RW_FOREIGN
X		RW_FOUND
X		RW_FROM
X		RW_GO
X		RW_GOTO
X		RW_GRANT
X		RW_GROUP
X		RW_HAVING
X		RW_IN
X		RW_INDICATOR
X		RW_INSERT
X		RW_INTEGER
X		RW_INTO
X		RW_IS
X		RW_KEY
X		RW_LANGUAGE
X		RW_LIKE
X		RW_MAX
X		RW_MIN
X		RW_MODULE
X		RW_NOT
X		RW_NULL
X		RW_NUMERIC
X		RW_OF
X		RW_ON
X		RW_OPEN
X		RW_OPTION
X		RW_OR
X		RW_ORDER
X		RW_PRECISION
X		RW_PRIMARY
X		RW_PRIVILEGES
X		RW_PROCEDURE
X		RW_PUBLIC
X		RW_REAL
X		RW_REFERENCES
X		RW_ROLLBACK
X		RW_SCHEMA
X		RW_SECTION
X		RW_SELECT
X		RW_SET
X		RW_SMALLINT
X		RW_SOME
X		RW_SQL
X		RW_SQLCODE
X		RW_SQLERROR
X		RW_SUM
X		RW_TABLE
X		RW_TO
X		RW_UNION
X		RW_UNIQUE
X		RW_UPDATE
X		RW_USER
X		RW_VALUES
X		RW_VIEW
X		RW_WHENEVER
X		RW_WHERE
X		RW_WITH
X		RW_WORK
X
X/*-------------------- Embedded Language specific tokens --------------------*/
X%token		RW_C
X		RW_CHAR
X		RW_INT
X
X/*
X%token		RW_COBOL
X		RW_COMP
X		RW_LEADING
X		RW_PIC
X		RW_SIGN
X		RW_SEPARATE
X		RW_USAGE
X
X%token		RW_FORTRAN
X
X%token		RW_PASCAL
X		RW_CHAR
X		RW_ARRAY
X		RW_PACKED
X
X%token		RW_PLI
X		RW_BINARY
X		RW_CHAR
X		RW_FIXED
X*/
X
X%%
X/*****************************************************************************/
X
X/*---------------------------------------------------------------------------*/
X/*			   Parser for Module				     */
X/*---------------------------------------------------------------------------*/
X
X@MODULE
Xansi_sql_module:
X	module
X	;
X@
X
X/*---------------------------------------------------------------------------*/
X/*			    Parser for ESQL				     */
X/*---------------------------------------------------------------------------*/
X
X@EMBEDDED
Xansi_sql_embedded:
X	  embedded_sql_statement
X	  { return ; }
X	| embedded_sql_declare_section
X	  { return ; }
X	;
X@
X
X/*-----------------------------------------------------------------------------
XParser for SQL Statements
X-----------------------------------------------------------------------------*/
X@INTERNAL
Xansi_sql_internal_statement:
X	  sql_statement
X	| declare_cursor
X	| schema
X	;
X@
X
X/*------------------ B <Embedded Exception Declaration> ---------------------*/
X
X@EMBEDDED
Xembedded_exception_declaration:
X	RW_WHENEVER condition exception_action
X	;
X
Xcondition:
X	  RW_SQLERROR
X	| RW_NOT RW_FOUND
X	;
X
Xexception_action:
X	RW_CONTINUE
X	| RW_GOTO target
X	;
X
Xtarget:
X	COLON host_identifier
X	| NUMERIC
X	;
X@
X
X/*-------------------- A <Embedded SQL host program> ------------------------*/
X
X@EMBEDDED
X
Xembedded_sql_statement:
X	  sql_prefix declare_cursor sql_terminator
X	| embedded_exception_declaration
X	| sql_prefix sql_statement sql_terminator
X	| sql_prefix schema sql_terminator
X	;
X
Xsql_prefix:
X	RW_SQL
X	;
X
Xsql_terminator:
X	RW_END RW_EXEC
X	| SEMICOLON
X	;
X
Xembedded_sql_declare_section:
X	sql_prefix RW_BEGIN RW_DECLARE RW_SECTION sql_terminator
X	host_variable_definition_list SEMICOLON
X	RW_EXEC sql_prefix RW_END RW_DECLARE RW_SECTION sql_terminator
X	;
X
Xhost_variable_definition_list:
X	  c_variable_definition
X	| host_variable_definition_list SEMICOLON c_variable_definition
X	;
X
Xc_variable_definition:
X	  RW_CHAR IDENTIFIER
X	| RW_CHAR IDENTIFIER LBRACKET UINTEGER RBRACKET
X	| RW_INT IDENTIFIER
X	| RW_FLOAT IDENTIFIER
X	| RW_DOUBLE IDENTIFIER
X	;
X@
X
X/*------------------ 8.12 <Update Statement: Searched> ----------------------*/
X
Xupdate_statement_search:
X	RW_UPDATE table_name
X	RW_SET set_clause_list
X	RW_WHERE search_condition
X	;
X
X/*----------------- 8.11 <Update Statement: Positioned> ---------------------*/
X
Xupdate_statement_position:
X	RW_UPDATE table_name
X	RW_SET set_clause_list
X	RW_WHERE RW_CURRENT RW_OF cursor_name
X	;
X
Xset_clause_list:
X	set_clause
X	| set_clause_list COMA set_clause
X	;
X
Xset_clause:
X	  column_name EQ value_expression
X	| column_name EQ RW_NULL
X	;
X
X/*----------------------- 8.10 <Select Statement> ---------------------------*/
X
X@!INTERNAL
Xselect_statement:
X	RW_SELECT op_ad select_list
X	RW_INTO select_target_list
X	table_expression
X	;
X
Xselect_target_list:
X	  target_specification
X	| select_target_list COMA target_specification
X	;
X@
X
X/*---------------------- 8.9 <Rollback Statement> ---------------------------*/
X
Xrollback_statement:
X	RW_ROLLBACK RW_WORK
X	;
X
X/*------------------------ 8.8 <Open Statement> -----------------------------*/
X
Xopen_statement:
X	RW_OPEN cursor_name
X	;
X
X/*------------------------ 8.7 <Insert Statement> ---------------------------*/
X
Xinsert_statement:
X	  RW_INSERT RW_INTO table_name op_insert_column_list
X	  RW_VALUES LPAREN insert_value_list RPAREN
X	| RW_INSERT RW_INTO table_name op_insert_column_list
X	  query_specification
X	;
X
Xop_insert_column_list:
X	| LPAREN insert_column_list RPAREN
X	;
X
Xinsert_column_list:
X	column_name
X	| insert_column_list COMA column_name
X	;
X
Xinsert_value_list:
X	insert_value
X	| insert_value_list COMA insert_value
X	;
X
Xinsert_value:
X	value_specification
X	| RW_NULL
X	;
X
X/*------------------------ 8.6 <Fetch Statement> ----------------------------*/
X
Xfetch_statement:
X	RW_FETCH cursor_name
X@!INTERNAL
X	RW_INTO fetch_target_list
X@
X	;
X
X@!INTERNAL
Xfetch_target_list:
X	target_specification
X	| fetch_target_list COMA target_specification
X	;
X@
X
X/*------------------- 8.5 <Delete Statement: Searched> ----------------------*/
X
Xdelete_statement_search:
X	RW_DELETE RW_FROM table_name
X	op_where_clause
X	;
X
X/*------------------ 8.4 <Delete Statement: Positioned> ---------------------*/
X
Xdelete_statement_position:
X	RW_DELETE RW_FROM table_name
X	RW_WHERE RW_CURRENT RW_OF cursor_name
X	;
X
X/*------------------------ 8.3 <Declare Cursor> -----------------------------*/
X
Xdeclare_cursor:
X	RW_DECLARE cursor_name RW_CURSOR
X	RW_FOR cursor_specification
X	;
X
Xcursor_specification:
X	  query_expression
X	| query_expression order_by_clause
X	;
X
Xquery_expression:
X	  query_term
X	| query_expression RW_UNION op_all query_term 
X	;
X
Xquery_term:
X	query_specification
X	| LPAREN query_expression RPAREN
X	;
X
Xorder_by_clause:
X	RW_ORDER RW_BY sort_specification_list
X	;
X
Xsort_specification_list:
X	sort_specification
X	| sort_specification_list COMA sort_specification
X	;
X
Xsort_specification:
X	  NUMERIC op_asc_desc
X	| column_specification op_asc_desc
X	;
X
Xop_asc_desc:
X	| RW_ASC
X	| RW_DESC
X	;
X
X/*------------------------ 8.2 <Commit Statement> ---------------------------*/
X
Xcommit_statement:
X	RW_COMMIT RW_WORK
X	;
X
X/*------------------------ 8.1 <Close Statement> ----------------------------*/
X
Xclose_statement:
X	RW_CLOSE cursor_name
X	;
X
X/*--------------------------- 7.3 <Procedure> -------------------------------*/
X
X@MODULE
Xprocedure:
X	  RW_PROCEDURE procedure_name parameter_declaration_list SEMICOLON
X		sql_statement SEMICOLON
X	| RW_PROCEDURE procedure_name parameter_declaration_list SEMICOLON
X		schema SEMICOLON
X	;
X
Xparameter_declaration_list:
X	  parameter_declaration
X	| parameter_declaration_list parameter_declaration
X	;
X
Xparameter_declaration:
X	  parameter_name data_type
X	| RW_SQLCODE
X	;
X@
X
Xsql_statement:
X	  close_statement
X	| commit_statement
X	| delete_statement_position
X	| delete_statement_search
X	| fetch_statement
X	| insert_statement
X	| open_statement
X	| rollback_statement
X@!INTERNAL
X	| select_statement
X@
X@INTERNAL
X	| cursor_specification
X@
X	| update_statement_position
X	| update_statement_search
X	/*
X	| table_definition
X	| view_definition
X	| privilege_definition
X	*/
X	;
X
X/*----------------------- 7.2 <Module Name Clause> --------------------------*/
X
X@MODULE
Xmodule_name_clause:
X	  RW_MODULE
X	| RW_MODULE module_name
X	;
X@
X
X/*----------------------------- 7.1 <Module> --------------------------------*/
X
X@MODULE
Xmodule:
X	module_name_clause
X	language_clause
X	module_authorization_clause
X	op_declare_cursor_list
X	procedure_list
X	;
X
Xlanguage_clause:
X	RW_LANGUAGE lang_type
X	;
X
Xlang_type:
X	  RW_C
X/*
X	| RW_COBOL
X	| RW_FORTRAN
X	| RW_PASCAL
X	| RW_PLI
X*/
X	;
X
Xmodule_authorization_clause:
X	| RW_AUTHORIZATION module_authorization_identifier
X	;
X
Xmodule_authorization_identifier:
X	authorization_identifier
X	;
X
Xop_declare_cursor_list:
X	| declare_cursor_list
X	;
X
Xdeclare_cursor_list:
X	declare_cursor
X	| declare_cursor_list declare_cursor
X	;
X
Xprocedure_list:
X	  procedure
X	| procedure_list procedure
X	;
X
X@
X
X/*---------------------- 6.10 <privilege definition> ------------------------*/
X
Xprivilege_definition:
X	RW_GRANT privileges RW_ON table_name
X	RW_TO grantee_list
X	op_with_grant_option
X	;
X
Xop_with_grant_option:
X	| RW_WITH RW_GRANT RW_OPTION
X	;
X
Xprivileges:
X	RW_ALL RW_PRIVILEGES
X	| action_list
X	;
X
Xaction_list:
X	action
X	| action_list COMA action
X	;
X
Xaction:
X	RW_SELECT
X	| RW_INSERT
X	| RW_DELETE
X	| RW_UPDATE op_grant_column_list
X	;
X
Xop_grant_column_list:
X	| LPAREN grant_column_list RPAREN
X	;
X
Xgrant_column_list:
X	  column_name
X	| grant_column_list COMA column_name
X	;
X
Xgrantee_list:
X	  grantee
X	| grantee_list COMA grantee
X	;
X
Xgrantee:
X	RW_PUBLIC
X	| authorization_identifier
X	;
X
X/*------------------------- 6.9 <view definition> ---------------------------*/
X
Xview_definition:
X	RW_CREATE RW_VIEW table_name op_view_column_list
X	RW_AS query_specification
X	op_with_check_option
X	;
X
Xop_view_column_list:
X	| LPAREN view_column_list RPAREN
X	;
X
Xview_column_list:
X	column_name
X	| view_column_list COMA column_name
X	;
X
Xop_with_check_option:
X	| RW_WITH RW_CHECK RW_OPTION
X	;
X
X/*----------------- 6.8 <Check Constraint Definition> -----------------*/
X
Xcheck_constraint_definition:
X	RW_CHECK LPAREN search_condition RPAREN
X	;
X
X/*----------------- 6.7 <Referential Constraint Definition> -----------------*/
X
Xreferential_constraint_definition:
X	RW_FOREIGN RW_KEY LPAREN references_columns RPAREN
X	references_specification
X	;
X
Xreferences_specification:
X	RW_REFERENCES referenced_table_and_columns
X	;
X
Xreferences_columns:
X	references_column_list
X	;
X
Xreferenced_table_and_columns:
X	  table_name
X	| table_name LPAREN references_column_list RPAREN
X	;
X
Xreferences_column_list:
X	  column_name
X	| references_column_list COMA column_name
X	;
X
X/*------------------- 6.6 <Unique Constraint Definition> --------------------*/
X
Xunique_constraint_definition:
X	  RW_UNIQUE LPAREN unique_column_list RPAREN
X	| RW_PRIMARY RW_KEY LPAREN unique_column_list RPAREN
X	;
X
Xunique_column_list:
X	  column_name
X	| unique_column_list COMA column_name
X	;
X	
X/*------------------- 6.5 <Table Constraint Definition> --------------------*/
X
Xtable_constraint_definition:
X	unique_constraint_definition
X	| referential_constraint_definition
X	| check_constraint_definition
X	;
X
X/*-------------------------- 6.4 <Default Clause> ---------------------------*/
X
Xdefault_clause:
X	  RW_DEFAULT literal
X	| RW_DEFAULT RW_NULL
X	| RW_DEFAULT RW_USER
X	;
X
X/*------------------------ 6.3 <Column Definition> --------------------------*/
X
Xcolumn_definiton:
X	column_name data_type
X	op_default_clause
X	op_column_constraint_list
X	;
X
Xop_default_clause:
X	|default_clause
X	;
X
Xop_column_constraint_list:
X	| column_constraint op_column_constraint_list
X	;
X
Xcolumn_constraint:
X	  RW_NOT RW_NULL
X	| RW_NOT RW_NULL RW_UNIQUE
X	| references_specification
X	| RW_CHECK LPAREN search_condition RPAREN
X	;
X
X/*------------------------ 6.2 <table definition> ---------------------------*/
X
Xtable_definition:
X	RW_CREATE RW_TABLE table_name
X	LPAREN  table_element_list RPAREN
X	;
X
Xtable_element_list:
X	  table_element
X	| table_element_list COMA table_element
X	;
X	
Xtable_element:
X	  column_definiton
X	| table_constraint_definition
X	;
X	
X/*----------------------------- 6.1 <schema> --------------------------------*/
X
Xschema:
X	RW_CREATE RW_SCHEMA schema_authorization_clause
X	schema_element_list
X	;
X
Xschema_authorization_clause:
X	RW_AUTHORIZATION schema_authorization_identifier
X	;
X
Xschema_authorization_identifier:
X	authorization_identifier
X	;
X
Xschema_element_list:
X	  schema_element
X	| schema_element_list schema_element
X	;
X
Xschema_element:
X	  table_definition
X	| view_definition
X	| privilege_definition
X	;
X
X/*****************************************************************************/
X/*---------------------- 5.25 <query specification> -------------------------*/
X
Xquery_specification:
X	RW_SELECT op_ad select_list table_expression
X	;
X
Xselect_list:
X	  value_expression_list
X	| MULT
X	;
X
Xvalue_expression_list:
X	  value_expression
X	| value_expression_list COMA value_expression
X	;
X
X/*---------------------------- 5.24 <subquery> ------------------------------*/
X
Xsubquery:
X	LPAREN RW_SELECT op_ad result_specification table_expression RPAREN
X	;
X
Xop_ad:
X	| RW_ALL
X	| RW_DISTINCT
X	;
X
Xresult_specification:
X	value_expression
X	| MULT
X	;
X
X/*------------------------- 5.23 <having clause> ----------------------------*/
X
Xhaving_clause:
X	RW_HAVING search_condition
X	;
X
X/*------------------------ 5.22 <group by clause> ---------------------------*/
X
Xgroup_by_clause:
X	RW_GROUP RW_BY column_specification_list
X
Xcolumn_specification_list:
X	  column_specification
X	| column_specification_list COMA column_specification
X	;
X
X/*-------------------------- 5.21 <where clause> ----------------------------*/
X
Xwhere_clause:
X	RW_WHERE search_condition
X	;
X
X/*-------------------------- 5.20 <from clause> -----------------------------*/
X
Xfrom_clause:
X	RW_FROM table_reference_list
X	;
X
Xtable_reference_list:
X	  table_reference
X	| table_reference_list COMA table_reference
X	;
X
Xtable_reference:
X	  table_name
X	| table_name correlation_name
X	;
X
X/*----------------------- 5.19 <search condiction> --------------------------*/
X
Xtable_expression:
X	from_clause
X	op_where_clause
X	op_group_by_clause
X	op_having_clause
X	;
X
Xop_where_clause:
X	| where_clause
X	;
X
Xop_group_by_clause:
X	| group_by_clause
X	;
X
Xop_having_clause:
X	| having_clause
X	;
X
X/*----------------------- 5.18 <search condiction> --------------------------*/
X
Xsearch_condition:
X	boolean_term
X	| search_condition RW_OR boolean_term
X	;
X
Xboolean_term:
X	boolean_factor
X	| boolean_term RW_AND boolean_factor
X	;
X
Xboolean_factor:
X	  boolean_primary
X	| RW_NOT boolean_primary
X	;
X
Xboolean_primary:
X	  predicate
X	| LPAREN search_condition RPAREN
X	;
X
X/*------------------------ 5.17 <exists_predicate> --------------------------*/
X
Xexists_predicate:
X	RW_EXISTS subquery
X	;
X
X/*---------------------- 5.16 <quantified_predicate> ------------------------*/
X
Xquantified_predicate:
X	value_expression comp_op quantifier subquery
X	;
X
Xquantifier:
X	  all
X	| some
X	;
Xall:
X	RW_ALL
X	;
X
Xsome:
X	  RW_SOME
X	| RW_ANY
X	;
X
X/*------------------------- 5.15 <null_predicate> ---------------------------*/
X
Xnull_predicate:
X	column_specification RW_IS op_not RW_NULL
X	;
X
X/*------------------------- 5.14 <like_predicate> ---------------------------*/
X
Xlike_predicate:
X	  column_specification op_not RW_LIKE pattern op_escape
X	;
X
Xop_escape:
X	| RW_ESCAPE escape_character
X	;
X
Xpattern:
X	  value_specification
X	;
X
Xescape_character:
X	  value_specification
X	;
X
X/*-------------------------- 5.13 <in_predicate> ----------------------------*/
X
Xin_predicate:
X	  value_expression op_not RW_IN subquery
X	| value_expression op_not RW_IN LPAREN in_value_list RPAREN
X	;
X
Xin_value_list:
X	  value_specification
X	| in_value_list COMA value_specification
X	;
X
X/*------------------------ 5.12 <between_predicate> -------------------------*/
X
Xbetween_predicate:
X	value_expression op_not
X		RW_BETWEEN value_expression RW_AND value_expression
X	;
X
Xop_not:
X	| RW_NOT
X	;
X
X/*---------------------- 5.11 <comparison_predicate> ------------------------*/
X
Xcomparison_predicate:
X	  value_expression comp_op value_expression
X	| value_expression comp_op subquery
X	;
X
Xcomp_op:
X	  EQ
X	| NEQ
X	| LT
X	| GT
X	| LE
X	| GE
X	;
X
X/*--------------------------- 5.10 <predicate> ------------------------------*/
X
Xpredicate:
X	  comparison_predicate
X	| between_predicate
X	| in_predicate
X	| like_predicate
X	| null_predicate
X	| quantified_predicate
X	| exists_predicate
X	;
X
X/*------------------------ 5.9 <value expression> ---------------------------*/
X
Xvalue_expression:
X	  value_expression MULT value_expression 
X	| value_expression DIV value_expression 
X	| value_expression PLUS value_expression 
X	| value_expression SUB value_expression 
X	| primary
X	| factor
X	;
X
Xfactor:
X	  PLUS primary
X	| SUB primary
X	;
X
Xprimary:
X	  value_specification
X	| column_specification
X	| set_function_specification
X	| LPAREN value_expression RPAREN
X	;
X
X/*------------------- 5.8 <set function specification> ----------------------*/
X
Xset_function_specification:
X	RW_COUNT LPAREN MULT RPAREN
X	| distinct_set_function
X	| all_set_function
X	;
X
Xdistinct_set_function:
X	  RW_AVG LPAREN RW_DISTINCT column_specification RPAREN
X	| RW_MAX LPAREN RW_DISTINCT column_specification RPAREN
X	| RW_MIN LPAREN RW_DISTINCT column_specification RPAREN
X	| RW_SUM LPAREN RW_DISTINCT column_specification RPAREN
X	| RW_COUNT LPAREN RW_DISTINCT column_specification RPAREN
X	;
X
Xall_set_function:
X	  RW_AVG LPAREN op_all value_expression RPAREN
X	| RW_MAX LPAREN op_all value_expression RPAREN
X	| RW_MIN LPAREN op_all value_expression RPAREN
X	| RW_SUM LPAREN op_all value_expression RPAREN
X	| RW_COUNT LPAREN op_all value_expression RPAREN
X	;
X
Xop_all:
X	| RW_ALL
X	;
X
X
X/*--------------------- 5.7 <column specification> --------------------------*/
Xcolumn_specification:
X	column_name
X	| IDENTIFIER PERIOD column_name
X	;
X
X/*
Xqualifier::=
X	<table_name> | <correlation_name>
X*/
X
X/*---------- 5.6 <value specification> and <target specification> -----------*/
X
Xvalue_specification:
X	  parameter_specification
X	| variable_specification
X	| literal
X	| RW_USER
X	;
X
X@!INTERNAL
Xtarget_specification:
X	  parameter_specification
X	| variable_specification
X	;
X@
X
Xparameter_specification:
X	  IDENTIFIER IDENTIFIER
X	| IDENTIFIER RW_INDICATOR IDENTIFIER
X	;
X
Xvariable_specification:
X	COLON IDENTIFIER
X	| COLON IDENTIFIER op_indicator COLON IDENTIFIER
X	;
X
Xop_indicator:
X	| RW_INDICATOR
X	;
X
X/*
X<target_specification>::=
X	<parameter_specification> | <variable_specification>
X
Xparameter_specification:
X	parameter_name indicator_parameter
X	;
X
Xindicator_parameter:
X	op_indicator parameter_name
X	;
X
Xvariable_specification:
X	embedded_variable_name indicator_variable
X	;
X
Xindicator_variable:
X	op_indicator embedded_variable_name
X	;
X*/
X
X/*--------------------------- 5.5 <data type> -------------------------------*/
X
Xdata_type:
X	  char_string_type
X	| exact_numeric_type
X	| approx_numeric_type
X	;
X
Xchar_string_type:
X	  RW_CHARACTER
X	| RW_CHARACTER LPAREN length RPAREN
X	;
X
Xexact_numeric_type:
X	RW_NUMERIC LPAREN precision op_scale RPAREN
X	| RW_DECIMAL LPAREN precision op_scale RPAREN
X	| RW_INTEGER
X	| RW_SMALLINT
X	;
X
Xop_scale:
X	| COMA scale
X	;
X
Xapprox_numeric_type:
X	RW_FLOAT LPAREN precision RPAREN
X	| RW_REAL
X	| RW_DOUBLE RW_PRECISION
X	;
X
Xlength:
X	UINTEGER
X	;
X
Xprecision:
X	UINTEGER
X	;
X
Xscale:
X	UINTEGER
X	;
X
X/*----------------------------- 5.4 Names -----------------------------------*/
Xtable_name:
X	table_identifier
X	| authorization_identifier PERIOD table_identifier
X	;
X
Xauthorization_identifier:
X	IDENTIFIER
X	;
X
Xtable_identifier:
X	IDENTIFIER
X	;
X
Xcolumn_name:
X	IDENTIFIER
X	;
X
Xcorrelation_name:
X	IDENTIFIER
X	;
X
X@EMBEDDED
Xhost_identifier:
X	IDENTIFIER
X	;
X@
X
Xcursor_name:
X	IDENTIFIER
X	;
X
X@MODULE
Xmodule_name:
X	IDENTIFIER
X	;
X
Xprocedure_name:
X	IDENTIFIER
X	;
X
Xparameter_name:
X	IDENTIFIER
X	;
X@
X
X/*---------------------------- 5.2 <literal> --------------------------------*/
X
Xliteral:
X	  STRING
X	| NUMERIC
X	| UINTEGER
X	| SINTEGER
X	;
X%%
X
X/*---------------------------------------------------------------------------*/
X#ifdef INTERNAL
Xextern char	*sqlbuf;
X#	include "ilex.yy.c"
X#else
X#	include "lex.yy.c"
X#endif
X
X/*---------------------------------------------------------------------------*/
Xyyerror(s)
Xchar	*s;
X{
X	fprintf(stderr,"%d:%s\n",yylineno,s);
X}
X
Xyywrap()
X{
X	return 1;
X}
SHAR_EOF
sed 's/^X//' << 'SHAR_EOF' > src/asqlca.h
X/* SQL Control Area */
X
Xtypedef struct
X{
X	long sqlcode;		/* SQL Status word */
X	char sqlerrm[72];	/* error message paramaters */
X	char sqlerrp[8];
X	long sqlerrd[4];	/* Other status words */
X	/* 0 - reserved        */
X	/* 1 - number of rows processed */
X	/* 2 - offset to position of error in SQL string */
X	/* 3 - rowid after insert  */
X	long sqlwarn;
X}SQLCA;
X
X#define SQLNOTFOUND 100
X
XSQLCA	*sqlfunc();
X
SHAR_EOF
sed 's/^X//' << 'SHAR_EOF' > src/asqlda.h
Xtypedef struct
X{
X	unsigned char	*data;
X}SQLDA;
SHAR_EOF
sed 's/^X//' << 'SHAR_EOF' > src/test.c
X/*
X * This software is Copyright (c)  1989 by Leroy Cain.
X *
X * Permission is hereby granted to copy, reproduce, redistribute or
X * otherwise use this software as long as: there is no monetary
X * profit gained specifically from the use or reproduction or this
X * software, it is not sold, rented, traded or otherwise marketed
X * except under licence from the author, and this copyright notice
X * is included prominently in any copy made.
X *
X * The author makes no claims as to the fitness or correctness of
X * this software for any use whatsoever, and it is provided as is. 
X * Any use of this software is at the user's own risk.
X *
X */
X
X#include <stdio.h>
X#include "asqlca.h"
X#include "asqlda.h"
X
Xmain(argc,argv)
Xint	argc;
Xchar	*argv[];
X{
Xchar	buf[1024];
XSQLDA	sqlda;
X
X	while( get_query(buf) != EOF )
X	{
X		sqlfunc(buf,sqlda);
X	}
X	putchar('\n');
X}
X
Xget_query(buf)
Xchar	*buf;
X{
Xint	c;
Xint	ln;
X
X	ln=1;
X	printf("%1d>>",ln++);
X	while( (c=getchar()) != EOF && c != ';')
X	{
X		*buf++ = c;
X		if(c=='\n')
X			printf("%1d>>",ln++);
X	}
X	*buf = '\0';
X	if(c==EOF)
X		return c;
X	while( (c=getchar()) != EOF && c != '\n')
X	return c;
X}
SHAR_EOF
sed 's/^X//' << 'SHAR_EOF' > src/module.c
X/*
X * This software is Copyright (c)  1989 by Leroy Cain.
X *
X * Permission is hereby granted to copy, reproduce, redistribute or
X * otherwise use this software as long as: there is no monetary
X * profit gained specifically from the use or reproduction or this
X * software, it is not sold, rented, traded or otherwise marketed
X * except under licence from the author, and this copyright notice
X * is included prominently in any copy made.
X *
X * The author makes no claims as to the fitness or correctness of
X * this software for any use whatsoever, and it is provided as is. 
X * Any use of this software is at the user's own risk.
X *
X */
X#include <stdio.h>
X
X/*
Xmodule file.msql
X*/
Xmain(argc,argv)
Xint	argc;		/* Argument Count */
Xchar	*argv[];	/* Argument Vector */
X{
Xint	c;		/* Current command line argument */
Xint	errflg;		/* Error flag */
XFILE	*modfd;		/* Module file descriptor */
Xextern char	*optarg;/* Option argument */
Xextern int	optind;/* Option index */
X
X	errflg=0;
X	/* Get arguments */
X	while((c = getopt(argc,argv,"l:")) != -1)
X	{
X		switch(c)
X		{
X		case 'l':
X			break;
X		case '?':
X			errflg++;
X		}
X	}
X
X	if(optind>=argc && argc!=1)
X	{
X		fprintf(stderr,"module [-ll] [filename]\n");
X		exit(1);
X	}
X
X	/* if no argument then stdin otherwise open file */
X	if(argc>1)
X	{
X		if(!((modfd=fopen(argv[optind],"r")) != NULL))
X		{
X			fprintf(stderr,"Can't open file %s\n",argv[optind]);
X			exit(1);
X		}
X#ifdef ansi
X	_stp->_fblk[0] = *modfd;
X#else
X		_iob[0] = *modfd;
X#endif
X	}
X
X	yyparse();
X}
SHAR_EOF
sed 's/^X//' << 'SHAR_EOF' > src/esqlc.c
X/*
X * This software is Copyright (c)  1989 by Leroy Cain.
X *
X * Permission is hereby granted to copy, reproduce, redistribute or
X * otherwise use this software as long as: there is no monetary
X * profit gained specifically from the use or reproduction or this
X * software, it is not sold, rented, traded or otherwise marketed
X * except under licence from the author, and this copyright notice
X * is included prominently in any copy made.
X *
X * The author makes no claims as to the fitness or correctness of
X * this software for any use whatsoever, and it is provided as is. 
X * Any use of this software is at the user's own risk.
X *
X */
X
X#include <stdio.h>
X#include "y.esql.h"
X
X/*
XEmbedded SQL file.esql
X*/
Xmain(argc,argv)
Xint	argc;		/* Argument Count */
Xchar	*argv[];	/* Argument Vector */
X{
Xint	c;		/* Current command line argument */
Xint	errflg;		/* Error flag */
XFILE	*esqlfd;		/* ESQL file descriptor */
Xextern char	*optarg;/* Option argument */
Xextern int	optind;/* Option index */
X
X	errflg=0;
X	/* Get arguments */
X	while((c = getopt(argc,argv,"l:")) != -1)
X	{
X		switch(c)
X		{
X		case 'l':
X			break;
X		case '?':
X			errflg++;
X		}
X	}
X
X	if(optind>=argc && argc!= 1)
X	{
X		fprintf(stderr,"Usage:esql [file_name]\n");
X		exit(1);
X	}
X
X	/* open file */
X	if(argc>1)
X	{
X		if(!((esqlfd=fopen(argv[optind],"r")) != NULL))
X		{
X			fprintf(stderr,"Can't open file %s\n",argv[optind]);
X		}
X#ifdef ansi
X		_stp->_fblk[0] = *esqlfd;
X#else
X		_iob[0] = *esqlfd;
X#endif
X	}
X
X	while( (c=yylex())>0 )
X	{
X		if( c==RW_EXEC)
X		{
X			yyparse();
X		}
X	}
X}
SHAR_EOF
sed 's/^X//' << 'SHAR_EOF' > src/sqlfunc.c
X/*
X * This software is Copyright (c)  1989 by Leroy Cain.
X *
X * Permission is hereby granted to copy, reproduce, redistribute or
X * otherwise use this software as long as: there is no monetary
X * profit gained specifically from the use or reproduction or this
X * software, it is not sold, rented, traded or otherwise marketed
X * except under licence from the author, and this copyright notice
X * is included prominently in any copy made.
X *
X * The author makes no claims as to the fitness or correctness of
X * this software for any use whatsoever, and it is provided as is. 
X * Any use of this software is at the user's own risk.
X *
X */
X#include "asqlca.h"
X#include "asqlda.h"
X
Xchar	*sqlbuf;	/* Buffer for Lex */
X
XSQLCA	*sqlfunc(sqlstat,databuf)
Xchar	*sqlstat;
XSQLDA	*databuf;
X{
XSQLCA	status;
X
X	sqlbuf = sqlstat;
X	yyparse();
X
X	return &status;
X}
SHAR_EOF
sed 's/^X//' << 'SHAR_EOF' > src/yf.c
X/*
X * This software is Copyright (c)  1989 by Leroy Cain.
X *
X * Permission is hereby granted to copy, reproduce, redistribute or
X * otherwise use this software as long as: there is no monetary
X * profit gained specifically from the use or reproduction of this
X * software, it is not sold, rented, traded or otherwise marketed
X * except under licence from the author, and this copyright notice
X * is included prominently in any copy made.
X *
X * The author makes no claims as to the fitness or correctness of
X * this software for any use whatsoever, and it is provided as is. 
X * Any use of this software is at the user's own risk.
X *
X */
X
X#include <stdio.h>
X
X#define WRITE	1
X#define NOWRITE	2
X#define BUFFER	3
X#define TEST	4
X
X/* Action Table */
Xint	action[][4]=
X{
X/* state  token	1,	2,	3,	4 */
X/* 0  */	EOF,	NOWRITE,WRITE,	WRITE,
X/* 1  */ 	EOF,	BUFFER,	TEST,	BUFFER,
X/* 2  */	EOF,	NOWRITE,NOWRITE,NOWRITE,
X/* 3  */	EOF,	NOWRITE,NOWRITE,NOWRITE,
X/* 4  */	EOF,	WRITE,	WRITE,	WRITE,
X/* 5  */	EOF,	NOWRITE,WRITE,	WRITE
X};
X
X/* State Table */
Xint	states[][4]=
X{
X/* state  token	1,	2,	3,	4 */
X/* 0  */	0,	1,	0,	0,
X/* 1  */	0,	1,	1,	1,
X/* 2  */	0,	2,	3,	2,
X/* 3  */	0,	0,	3,	2,
X/* 4  */	0,	4,	5,	4,
X/* 5  */	0,	0,	5,	4
X};
X
X/*
XThis program is a filter that reads a YACC file on standard in and conditionaly
Xwrites the filtered output to standard out based on the value of argv[1] and
Xthe conditional statements found in the YACC file.  Condition statements
Xtake the form of:
X
X@switch
X...
X@
X
XOR
X
X@!switch
X...
X@
X
XWhere switch is some string that is equal to the value of argv[1].
X*/
Xmain(argc,argv)
Xint	argc;		/* Argument Count */
Xchar	*argv[];	/* Argument Values */
X{
Xint	c;		/* Current Character */
Xint	token;		/* Current Token */
Xint	state=0;	/* Current State */
Xchar	buf[256];	/* Buffer for Testing */
Xchar	*tb=buf;	/* Pointer to buffer */
X
X	for(;;)
X	{
X		/* Get Current Token */
X		token = ((c=getchar()) == EOF? 0: c=='@'? 1: c=='\n'?2:3);
X
X		/* Based on Current state and token select action */
X		switch(action[state][token])
X		{
X		case WRITE:
X			putchar(c);
X			break;
X		case NOWRITE:
X			break;
X		case BUFFER:
X			*tb++ = c; break;
X		case TEST:
X			*tb='\0';
X			if( *buf=='!')	/* @!switch */
X				state= !strcmp(argv[1],buf+1)?2:4;
X			else		/* @switch */
X				state=strcmp(argv[1],buf)?2:4;
X			tb=buf;
X			break;
X		case EOF:
X			exit(0);
X		}
X
X		/* Select new state based on current state and current token */
X		state=states[state][token];
X	}
X}
SHAR_EOF
sed 's/^X//' << 'SHAR_EOF' > test/embed01.esql
Xmain()
X{
XEXEC SQL BEGIN DECLARE SECTION END EXEC
XCHAR	Tvar1[10];
XINT	Tvar2;
XCHAR	Tvar3[10];
XFLOAT	Tvar4;
XEXEC SQL END DECLARE SECTION END EXEC
X}
SHAR_EOF
sed 's/^X//' << 'SHAR_EOF' > test/embed02.esql
X/*
X$include sqlca;
X*/
X
X/*
XThis program has been addapted from a Informix-ESQL program that I assign
Xfor the CPTR250 Intro to Database class I teach.
X*/
Xmain(argc,argv)
Xint	argc;
Xchar	*argv[];
X{
XEXEC SQL BEGIN DECLARE SECTION END EXEC
XCHAR	Hsname[16];	-- s_lname char(10) */
XCHAR	Hmajor[8];	-- s_major char(3) */
XCHAR	Hsid[8];	-- s_id char(3) */
XDOUBLE	Hgpa;		-- s_gpa decimal */
XEXEC SQL END DECLARE SECTION END EXEC
Xdouble	gpa;
X
X	if(argc>1)
X		strcpy(hsid,argv[1]);
X	else
X		exit(1);
X/*
X$	database college;
X*/
X
XEXEC SQL
X	SELECT S_lname, S_major, S_gpa
X	INTO :Hsname, :Hmajor, :Hgpa
X	FROM Student
X	WHERE S_id = Hsid
XEND EXEC
X
X	dectodbl(&hgpa,&gpa);
X	printf("Student name %s, Major %s, gpa = %f\n",hsname,hmajor,gpa);
X/*
X$	close database;
X*/
X}
SHAR_EOF
sed 's/^X//' << 'SHAR_EOF' > test/tm01.mod
XMODULE Test_001
XLANGUAGE C
XAUTHORIZATION Lcain
XPROCEDURE Close_cur SQLCODE;
X	CLOSE Cur1;
X
XPROCEDURE Commit_tran SQLCODE;
X	COMMIT WORK;
X
XPROCEDURE Delete_p SQLCODE;
X	DELETE FROM Tabname
X	WHERE CURRENT OF Curname;
X
X PROCEDURE Delete_s SQLCODE;
X 	DELETE FROM Tabname
X 	WHERE Col1 = +5.0;
X
XPROCEDURE Fetch_ SQLCODE;
X	FETCH Curname INTO Col1 INDICATOR Colind1;
X
XPROCEDURE Insert_ SQLCODE;
X	INSERT INTO Tabname (Col1,Col2,Col3)
X	VALUES ( 'Test',+5,-5.8 );
X
XPROCEDURE Open_cur SQLCODE;
X	OPEN Cur1;
X
XPROCEDURE Rollback_ SQLCODE;
X	ROLLBACK WORK;
X
XPROCEDURE List_table Colname CHARACTER( 10) SQLCODE;
X	SELECT Colname
X	INTO Colname INDICATOR Colind
X	FROM Tabname;
X
XPROCEDURE Update_p SQLCODE;
X	UPDATE Tabname
X	SET Col1 = Col1 * +3.5
X	WHERE CURRENT OF Curname;
X
XPROCEDURE Update_s SQLCODE;
X	UPDATE Tabname
X	SET Col2 = Col2 * +3.5
X	WHERE Col1 = 'Test';
SHAR_EOF
exit
